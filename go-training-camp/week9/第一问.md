# 总结几种粘包的解包方式

## 什么是粘包

> 多个数据包被连续存储于连续的缓存中，在对数据包进行读取时由于无法确定发生方的发送边界，而采用某一估测值大小来进行数据读出，若双方的size不一致时就会使指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

**首先我们要明确只有TCP才会有粘包现象，UDP是不会粘包**

1. TCP是面向字节流的，就像水流一样，是没有明确的边界的。当通过TCP连接发送报文的时候，如果报文太长可能会进行拆包，如果报文太短则会先保存到缓冲区内等到达一定的程度再进行发送。
2. UDP是面向报文的，不进行合并和拆分，一次只发送一个报文。

还有半包的概念，根据粘包的概念如果粘包就是一次性发送了1.x的包，半包就是发送了0.x的数据包。

## 为什么会发生粘包

主要3个原因

1. Socket缓冲区与滑动窗口

    1. 因为缓冲区的存在，发送数据包的时候会先缓存在缓冲区，等缓冲区满了或者满足一定条件，才会真实的去发送出去。同理也有接收缓冲区。

    2. 滑动窗口（**从网上copy的描述，之前不清楚**）：TCP连接在三次握手的时候，会将自己的窗口大小(window size)发送给对方，其实就是SO_RCVBUF指定的值。之后在发送数据的时，发送方必须要先确认接收方的窗口没有被填充满，如果没有填满，则可以发送。

       每次发送数据后，发送方将自己维护的对方的window size减小，表示对方的SO_RCVBUF可用空间变小。

       当接收方处理开始处理SO_RCVBUF 中的数据时，会将数据从socket 在内核中的接受缓冲区读出，此时接收方的SO_RCVBUF可用空间变大，即window size变大，接受方会以ack消息的方式将自己最新的window size返回给发送方，此时发送方将自己的维护的接受的方的window size设置为ack消息返回的window size。

       此外，发送方可以连续的给接受方发送消息，只要保证对方的SO_RCVBUF空间可以缓存数据即可，即window size>0。当接收方的SO_RCVBUF被填充满时，此时window size=0，发送方不能再继续发送数据，要等待接收方ack消息，以获得最新可用的window size。

2. MSS/MTU限制

   这个理由上次Redis的作业也提到过，比如家庭宽带里的MTU默认就是1480、1460或1500（大概率是1500）会有20字节IP头和TCP头，最终发送的消息基本是1460字节，大于这个包大小的肯定会被拆包。

3. Nagle算法（**陌生的领域**）

   Nagle 算法是一种通过减少数据包的方式提高 TCP 传输性能的算法。因为网络带宽有限，它不会将小的数据块直接发送到目的主机，而是会在本地缓冲区中等待更多待发送的数据，这种批量发送数据的策略虽然会影响实时性和网络延迟，但是能够降低网络拥堵的可能性并减少额外开销。

   > TCP/IP协议中，无论发送多少数据，总是要在数据(DATA)前面加上协议头(TCP Header+IP Header)，同时，对方接收到数据，也需要发送ACK表示确认。
   >
   > **即使从键盘输入的一个字符，占用一个字节，可能在传输上造成41字节的包，其中包括1字节的有用信息和40字节的首部数据。这种情况转变成了4000%的消耗，这样的情况对于重负载的网络来是无法接受的。称之为"糊涂窗口综合征"**。
   >
   > 为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。Nagle算法就是为了尽可能发送大块数据，避免网络中充斥着许多小数据块。
   >
   > Nagle算法的基本定义是任意时刻，最多只能有一个未被确认的小段。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。
   >
   > Nagle算法的规则：
   >
   > 1. 如果SO_SNDBUF中的数据长度达到MSS，则允许发送；
   > 2. 如果该SO_SNDBUF中含有FIN，表示请求关闭连接，则先将SO_SNDBUF中的剩余数据发送，再关闭；
   > 3. 设置了TCP_NODELAY=true选项，则允许发送。TCP_NODELAY是取消TCP的确认延迟机制，相当于禁用了Negale 算法。正常情况下，当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假一般是40ms），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。当然，TCP确认延迟40ms并不是一直不变的，TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。另外可以通过设置TCP_QUICKACK选项来取消确认延迟。
   > 4. 未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送;
   > 5. 上述条件都未满足，但发生了超时（一般为200ms），则立即发送。



## 解包方式

### fix length based frame decoder

个人理解：从直译来看是固定长度，双方约定好数据包的size，接收方每次只读取固定长度的数据包进行处理。（但是是否可以超过缓冲区大小或者MTU大小？**请老师帮忙解惑下**。因为超过缓冲区大小或者MTU也可以靠读取固定长度来正确处理数据包）

场景：一些信息不变的场景都可以，比如探活，每次只发送相同的数据包。



### delimiter based frame decoder

个人理解：使用固定的分隔符来进行分割，发送方和接收方约定好分隔符号，然后在完整的数据包后面跟上分隔符，接收方则是读取到分割符就认为是一个完整的数据包。

场景：比如银行批量报文解析，N笔数据可以使用特殊符号分割



### length field based frame decoder

个人理解：约定好报文的格式，比如前两位是报文版本号，第三位表示报文长度，然后发送方在计算好报文业务长度时可以再第三个字节处赋值实际的报文长度，然后接受者判断报文版本号和报文长度来确定整体的报文长度。

场景：比如加解密传输的时候，密文前就是密文的长度。




